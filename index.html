<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Luohino Chat</title>

  <script src="https://unpkg.com/peerjs@1.5.1/dist/peerjs.min.js"></script>

  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }

    body {
      background: #e6e7ee;
      background-image:
        radial-gradient(circle at 25% 25%, #f0f0f3 0%, transparent 50%),
        radial-gradient(circle at 75% 75%, #dddde3 0%, transparent 50%);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 20px;
    }

    .screen-container {
      width: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .container {
      background: #e6e7ee;
      border-radius: 25px;
      padding: 30px;
      width: 100%;
      box-shadow:
        20px 20px 60px #bebfc5,
        -20px -20px 60px #ffffff;
      border: 1px solid rgba(255,255,255,0.1);
    }

    #loginScreen {
      max-width: 420px;
    }

    #chatScreen {
      max-width: 900px;
      max-height: 90vh;
      overflow-y: auto;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 30px;
      align-items: start;
    }

    #chatScreen.hidden {
      display: none !important;
    }

    .left-panel, .right-panel {
      display: flex;
      flex-direction: column;
    }

    @media (max-width: 768px) {
      .container { padding: 25px; }
      #loginScreen { max-width: 380px; }
      #chatScreen { max-width: 420px; grid-template-columns: 1fr; gap: 20px; }
    }

    .hidden {
      display: none !important;
      visibility: hidden !important;
      opacity: 0 !important;
    }

    h1, h2 {
      text-align: center;
      margin-bottom: 25px;
      color: #4a4a4a;
      font-weight: 600;
      letter-spacing: -0.5px;
    }

    .user-selection {
      display: flex;
      gap: 15px;
      margin-bottom: 20px;
    }

    .user-option {
      flex: 1;
      padding: 18px 20px;
      background: #e6e7ee;
      color: #4a4a4a;
      border: none;
      border-radius: 18px;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 8px 8px 16px #bebfc5, -8px -8px 16px #ffffff;
    }

    .user-option.selected {
      box-shadow: inset 6px 6px 12px #bebfc5, inset -6px -6px 12px #ffffff;
      color: #2563eb;
    }

    input[type="password"], input[type="text"] {
      width: 100%;
      padding: 16px 20px;
      border: none;
      border-radius: 16px;
      font-size: 15px;
      margin-bottom: 20px;
      background: #e6e7ee;
      color: #4a4a4a;
      box-shadow: inset 6px 6px 12px #bebfc5, inset -6px -6px 12px #ffffff;
    }

    .btn {
      width: 100%;
      padding: 16px;
      background: #e6e7ee;
      color: #4a4a4a;
      border: none;
      border-radius: 16px;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      margin-bottom: 15px;
      box-shadow: 8px 8px 16px #bebfc5, -8px -8px 16px #ffffff;
    }

    .status-indicator {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 12px;
      padding: 16px;
      border-radius: 16px;
      margin-bottom: 25px;
      font-weight: 500;
      font-size: 14px;
      background: #e6e7ee;
      color: #4a4a4a;
      box-shadow: inset 3px 3px 6px #bebfc5, inset -3px -3px 6px #ffffff;
    }

    .status-online { color: #16a34a; }
    .status-offline { color: #dc2626; }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: currentColor;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .call-controls {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 15px;
      margin-bottom: 20px;
    }

    .control-btn {
      padding: 14px 16px;
      border: none;
      border-radius: 14px;
      font-weight: 500;
      cursor: pointer;
      font-size: 13px;
      background: #e6e7ee;
      color: #4a4a4a;
      box-shadow: 6px 6px 12px #bebfc5, -6px -6px 12px #ffffff;
    }

    .control-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .video-container {
      display: flex;
      gap: 15px;
      margin-bottom: 20px;
      justify-content: center;
    }

    .video-wrapper video {
      width: 150px;
      height: 100px;
      border-radius: 15px;
      background: #000;
      object-fit: cover;
    }

    .messages-container {
      background: #e6e7ee;
      border-radius: 15px;
      padding: 20px;
      min-height: 300px;
      max-height: 400px;
      overflow-y: auto;
      margin-bottom: 15px;
      box-shadow: inset 6px 6px 12px #bebfc5, inset -6px -6px 12px #ffffff;
    }

    .message {
      padding: 10px 15px;
      margin-bottom: 10px;
      border-radius: 20px;
      max-width: 80%;
      word-wrap: break-word;
    }

    .message.sent {
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
      margin-left: auto;
    }

    .message.received {
      background: white;
      border: 2px solid #e0e6ed;
      color: #2c3e50;
    }

    .message.system {
      background: transparent;
      color: #666;
      text-align: center;
      margin: 10px auto;
      font-style: italic;
      font-size: 12px;
    }

    .input-group { display: flex; gap: 10px; }
    .input-group input { flex: 1; margin-bottom: 0; }
    .input-group button { width: auto; padding: 15px 25px; margin-bottom: 0; }

    .user-info {
      text-align: center;
      padding: 15px;
      background: rgba(102, 126, 234, 0.1);
      border-radius: 15px;
      margin-bottom: 20px;
    }

    .user-avatar {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background: #e6e7ee;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #4a4a4a;
      font-size: 16px;
      font-weight: 600;
      margin: 0 auto 10px;
      box-shadow: 8px 8px 16px #bebfc5, -8px -8px 16px #ffffff;
    }
  </style>
</head>
<body>
  <!-- Login Screen -->
  <div id="loginScreen" class="container">
    <h1>Luohino Chat</h1>
    <h2>Select User</h2>
    <div class="user-selection">
      <button class="user-option" data-user="Luohino">Luohino</button>
      <button class="user-option" data-user="Tanaya">Tanaya</button>
    </div>
    <button class="btn" id="loginBtn">Login</button>
  </div>

  <!-- Main Chat Screen -->
  <div id="chatScreen" class="container hidden">
    <div class="left-panel">
      <div class="user-info">
        <div class="user-avatar" id="userAvatar"></div>
        <div id="userName"></div>
      </div>
      <div id="statusIndicator" class="status-indicator status-offline">
        <div class="status-dot"></div>
        <span id="statusText">Connecting...</span>
      </div>
      <div class="call-controls">
        <button class="control-btn" id="voiceCallBtn">Voice Call</button>
        <button class="control-btn" id="videoCallBtn">Video Call</button>
        <button class="control-btn" id="screenShareBtn">Screen Share</button>
        <button class="control-btn" id="endCallBtn" disabled>End Call</button>
      </div>
      <div class="video-container hidden" id="videoContainer">
        <div class="video-wrapper">
          <video id="localVideo" autoplay muted playsinline></video>
        </div>
        <div class="video-wrapper">
          <video id="remoteVideo" autoplay playsinline></video>
        </div>
      </div>
    </div>
    <div class="right-panel">
      <div class="messages-container" id="messagesContainer"></div>
      <div class="input-group">
        <input type="text" id="messageInput" placeholder="Type your message..." disabled/>
        <button class="btn" id="sendBtn" disabled>Send</button>
      </div>
    </div>
  </div>

  <script>
    const USERS = {
      'Luohino': { peerId: 'secure-chat-luohino-peer-id', avatar: 'L' },
      'Tanaya': { peerId: 'secure-chat-tanaya-peer-id', avatar: 'T' }
    };

    // Global state
    let currentUser = null;
    let otherUser = null;
    let peer = null;
    let dataConnection = null;
    let mediaConnection = null;
    let localStream = null;
    let wakeLock = null;
    let ecdhKeys = null;
    let sharedSecret = null;
    let remotePublicKey = null;

    // DOM elements
    const loginScreen = document.getElementById('loginScreen');
    const chatScreen = document.getElementById('chatScreen');
    const userOptions = document.querySelectorAll('.user-option');
    const loginBtn = document.getElementById('loginBtn');
    const userAvatar = document.getElementById('userAvatar');
    const userName = document.getElementById('userName');
    const statusText = document.getElementById('statusText');
    const messagesContainer = document.getElementById('messagesContainer');
    const messageInput = document.getElementById('messageInput');
    const sendBtn = document.getElementById('sendBtn');
    const videoContainer = document.getElementById('videoContainer');
    const localVideo = document.getElementById('localVideo');
    const remoteVideo = document.getElementById('remoteVideo');
    const voiceCallBtn = document.getElementById('voiceCallBtn');
    const videoCallBtn = document.getElementById('videoCallBtn');
    const screenShareBtn = document.getElementById('screenShareBtn');
    const endCallBtn = document.getElementById('endCallBtn');

    // --- Initialization ---
    userOptions.forEach(option => {
      option.addEventListener('click', () => {
        userOptions.forEach(opt => opt.classList.remove('selected'));
        option.classList.add('selected');
        currentUser = option.dataset.user;
        otherUser = currentUser === 'Luohino' ? 'Tanaya' : 'Luohino';
      });
    });

    loginBtn.addEventListener('click', () => {
      if (!currentUser) { alert("Please select a user"); return; }
      loginScreen.classList.add('hidden');
      chatScreen.classList.remove('hidden');
      userAvatar.textContent = USERS[currentUser].avatar;
      userName.textContent = currentUser;
      loadChatHistory();
      initializePeer();
    });

    function initializePeer() {
      addSystemMessage('Initializing connection...');
      peer = new Peer(USERS[currentUser].peerId);

      peer.on('open', id => {
        addSystemMessage(`Online as ${currentUser}. Trying to connect to ${otherUser}...`);
        connectToPeer();
      });
      peer.on('connection', setupDataConnection);
      peer.on('call', handleIncomingCall);
      peer.on('error', err => addSystemMessage(`Error: ${err.type}. Please refresh.`));
      peer.on('disconnected', () => {
          addSystemMessage('Disconnected from server. Reconnecting...');
          peer.reconnect();
      });
    }

    function connectToPeer() {
        const remotePeerId = USERS[otherUser].peerId;
        const conn = peer.connect(remotePeerId, { reliable: true });
        setupDataConnection(conn);
    }

    function setupDataConnection(conn) {
        if (dataConnection && dataConnection.open) return;
        dataConnection = conn;

        dataConnection.on('open', async () => {
            updateStatus(true, 'Connected, negotiating secret...');
            await generateKeysAndSendPublicKey();
        });
        dataConnection.on('data', handleIncomingData);
        dataConnection.on('close', () => {
            updateStatus(false, 'Disconnected');
            dataConnection = null;
            sharedSecret = null;
            setTimeout(connectToPeer, 5000);
        });
    }

    // --- Security (ECDH Key Exchange & AES-GCM Encryption) ---
    async function generateKeysAndSendPublicKey() {
        try {
            ecdhKeys = await window.crypto.subtle.generateKey({ name: 'ECDH', namedCurve: 'P-256' }, true, ['deriveKey']);
            const publicKeyRaw = await window.crypto.subtle.exportKey('raw', ecdhKeys.publicKey);
            dataConnection.send({ type: 'key_exchange', key: Array.from(new Uint8Array(publicKeyRaw)) });
        } catch (e) {
            addSystemMessage('Crypto key generation failed. Please use a modern browser.');
        }
    }

    async function deriveSharedSecret(remoteKeyData) {
        try {
            remotePublicKey = await window.crypto.subtle.importKey('raw', new Uint8Array(remoteKeyData), { name: 'ECDH', namedCurve: 'P-256' }, false, []);
            sharedSecret = await window.crypto.subtle.deriveKey(
                { name: 'ECDH', public: remotePublicKey },
                ecdhKeys.privateKey,
                { name: 'AES-GCM', length: 256 },
                true, ['encrypt', 'decrypt']
            );
            addSystemMessage('Secure connection established.');
            updateStatus(true, `Connected to ${otherUser}`);
        } catch (e) {
            addSystemMessage('Key exchange failed. Connection is not secure.');
        }
    }

    async function encryptMessage(jsonString) {
        if (!sharedSecret) throw new Error("No shared secret.");
        const iv = window.crypto.getRandomValues(new Uint8Array(12));
        const encryptedData = await window.crypto.subtle.encrypt({ name: 'AES-GCM', iv }, sharedSecret, new TextEncoder().encode(jsonString));
        return { iv: Array.from(iv), data: Array.from(new Uint8Array(encryptedData)) };
    }

    async function decryptMessage({ iv, data }) {
        if (!sharedSecret) throw new Error("No shared secret.");
        const decryptedData = await window.crypto.subtle.decrypt({ name: 'AES-GCM', iv: new Uint8Array(iv) }, sharedSecret, new Uint8Array(data));
        return new TextDecoder().decode(decryptedData);
    }

    // --- Data Handling ---
    async function handleIncomingData(payload) {
        try {
            if (payload.type === 'key_exchange') {
                await deriveSharedSecret(payload.key);
                if (!remotePublicKey) { // If we are the second to connect, send our key back
                    await generateKeysAndSendPublicKey();
                }
                return;
            }
            if (!sharedSecret) return; // Ignore data if not secure

            const decryptedJSON = await decryptMessage(payload);
            const data = JSON.parse(decryptedJSON);

            if (data.type === 'chat') {
                addMessage(data.content, 'received');
            }
        } catch (error) {
            addSystemMessage('Error processing received data.');
        }
    }

    async function sendMessage() {
        const message = messageInput.value.trim();
        if (message && dataConnection && dataConnection.open && sharedSecret) {
            try {
                const payload = { type: 'chat', content: message };
                const encryptedPayload = await encryptMessage(JSON.stringify(payload));
                dataConnection.send(encryptedPayload);
                addMessage(message, 'sent');
                messageInput.value = '';
            } catch (error) {
                addSystemMessage("Failed to send message.");
            }
        }
    }

    // --- Call Handling ---
    function startCall(options) {
        if (!dataConnection || !dataConnection.open) {
            addSystemMessage('Cannot start call: not connected.');
            return;
        }
        navigator.mediaDevices.getUserMedia(options)
            .then(stream => {
                cleanupCall(); // End any previous call
                localStream = stream;
                localVideo.srcObject = stream;
                if (options.video) videoContainer.classList.remove('hidden');

                mediaConnection = peer.call(dataConnection.peer, stream);
                setupMediaConnection();
                endCallBtn.disabled = false;
            })
            .catch(err => addSystemMessage(`Media access error: ${err.name}`));
    }

    function startScreenShare() {
        if (!dataConnection || !dataConnection.open) {
            addSystemMessage('Cannot share screen: not connected.');
            return;
        }
        navigator.mediaDevices.getDisplayMedia({ video: true, audio: true })
            .then(stream => {
                cleanupCall();
                localStream = stream;
                localVideo.srcObject = stream;
                videoContainer.classList.remove('hidden');

                mediaConnection = peer.call(dataConnection.peer, stream);
                setupMediaConnection();
                endCallBtn.disabled = false;
                stream.getVideoTracks()[0].onended = endCall;
            })
            .catch(err => addSystemMessage(`Screen share error: ${err.name}`));
    }

    function handleIncomingCall(call) {
        if (confirm(`${otherUser} is calling. Accept?`)) {
            navigator.mediaDevices.getUserMedia({ video: true, audio: true })
                .then(stream => {
                    cleanupCall();
                    localStream = stream;
                    localVideo.srcObject = stream;
                    videoContainer.classList.remove('hidden');

                    mediaConnection = call;
                    mediaConnection.answer(stream);
                    setupMediaConnection();
                    endCallBtn.disabled = false;
                })
                .catch(err => {
                    addSystemMessage(`Answering call failed: ${err.name}`);
                    call.close();
                });
        } else {
            call.close();
        }
    }

    function setupMediaConnection() {
        mediaConnection.on('stream', remoteStream => {
            remoteVideo.srcObject = remoteStream;
            videoContainer.classList.remove('hidden');
            requestWakeLock();
        });
        mediaConnection.on('close', cleanupCall);
        mediaConnection.on('error', () => {
            addSystemMessage('Call error.');
            cleanupCall();
        });
    }

    function endCall() {
        if (mediaConnection) mediaConnection.close();
        cleanupCall();
    }

    function cleanupCall() {
        if (localStream) {
            localStream.getTracks().forEach(track => track.stop());
        }
        localStream = null;
        localVideo.srcObject = null;
        remoteVideo.srcObject = null;
        videoContainer.classList.add('hidden');
        if (mediaConnection) {
            mediaConnection.close();
            mediaConnection = null;
        }
        endCallBtn.disabled = true;
        releaseWakeLock();
    }

    // --- UI & State Management ---
    function updateStatus(online, text) {
        statusText.textContent = text;
        const controls = [messageInput, sendBtn, voiceCallBtn, videoCallBtn, screenShareBtn];
        controls.forEach(el => el.disabled = !online);
    }

    function addMessage(text, type, isNew = true) {
      const messageDiv = document.createElement('div');
      messageDiv.className = `message ${type}`;
      messageDiv.textContent = text;
      messagesContainer.appendChild(messageDiv);
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
      if (isNew && type !== 'system') saveMessageToHistory({ text, type });
    }

    function addSystemMessage(text) { addMessage(text, 'system', false); }

    // --- Persistence ---
    function getChatHistoryKey() {
        const ids = [USERS['Luohino'].peerId, USERS['Tanaya'].peerId].sort();
        return `chatHistory_${ids[0]}_${ids[1]}`;
    }

    function loadChatHistory() {
        const history = localStorage.getItem(getChatHistoryKey());
        if (history) {
            JSON.parse(history).forEach(msg => addMessage(msg.text, msg.type, false));
        }
    }

    function saveMessageToHistory(message) {
        const key = getChatHistoryKey();
        const history = JSON.parse(localStorage.getItem(key) || '[]');
        history.push(message);
        localStorage.setItem(key, JSON.stringify(history));
    }

    // --- Wake Lock ---
    async function requestWakeLock() {
        if ('wakeLock' in navigator) {
            try {
                wakeLock = await navigator.wakeLock.request('screen');
            } catch (err) { console.error(`Wake Lock failed: ${err.message}`); }
        }
    }

    function releaseWakeLock() {
        if (wakeLock) wakeLock.release().then(() => { wakeLock = null; });
    }

    // --- Event Listeners ---
    sendBtn.addEventListener('click', sendMessage);
    messageInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') sendMessage(); });
    voiceCallBtn.addEventListener('click', () => startCall({ audio: true, video: false }));
    videoCallBtn.addEventListener('click', () => startCall({ audio: true, video: true }));
    screenShareBtn.addEventListener('click', startScreenShare);
    endCallBtn.addEventListener('click', endCall);
    window.addEventListener('beforeunload', () => { if (dataConnection) dataConnection.close(); });
  </script>
</body>
</html>